---
title: "Flight Ticket Price Analysis with Linear Regression"
author: "Jun Cai, Vikas Boddu"
date: February 11, 2016
output: html_document
---

This document describes an implementation of Mapreduce instance with Hadoop on the OTP flight ticket price dataset. The purpose of the application is to calculate the average ticket price for each month for each carrier in the given data. The application can run in two modes: local pseudo-distributed mode and cluster mode using AWS EMR instance.

<h3>Implementation</h3>
<h4>Input Data Processing</h4>
The format of the input data is compressed csv files. These gzipped files are store in the 'input' folder residing in HDFS under pseudo-distributed mode and in S3 bucket under cluster mode. Since the HDFS can automatically handle the decompressing of the gzipped file, there is no need to explicitly write code for that. The unzipped csv files will be the input of the Mapreduce. They will be read as a text file. Each line is parsed as a record using a simplified csv format parser.

<h4>Mapping</h4>
The mapper will map each record in the given data files to a key value pair, where the key is the carrier's unique identifier and the value is a string contains the date of the flight and the average ticket price of that flight. In this way we can calculate average ticket price for each month at the later reduce step. Records with invalid format will be mapped to a special key value pair to keep tracking the number of bad records. The key and value will all be string "INVALID" in this case.

<h4>Reducing</h4>
The key value pairs for the same carrier will be combined together before the reduce step. The reducer is responsible for several tasks. For invalid records, the reducer will calculate the total number of the them and the output will be "INVALID" string and number of invalid records pair. For each carrier, the reducer will first go through all the records for it and see if it is still active in 2015. If it's not an active carrier, all the records will be ignored. For active carriers, the number of records will be calculated, then the records will be grouped by month. Mean price for each month is calculated. There will be several outputs for every active carrier, each output is for one month. The key of the output is a string containing month, identifier of the carrier and the total number of flights for this carrier from all given data separated by commas. The value of the output is the mean price for that month for that carrier. Separator between key and value is set to comma so that the output file of the Mapreduce will be in csv format which can be easily read by R for further processing.

<h4>Results</h4>
The output files from Mapreduce is processed by a R script. Total numbers of flights of all carriers will be sorted. Identifiers of 10 carriers with most flights will be stored in a vector. Then the script uses each identifier in the vector as a filter to find all the outputs for that carrier. These outputs are sorted by month then be ploted on a graph (as shown below).

From the results, we can see that from Jan 2013 to Jan 2015, the monthly average ticket prices didn't change a lot for all the carriers. Though there seems to be a trend that the ticket prices going up slowly through this period of time.  

Following is the result graph created by R script. 

```{r, echo=FALSE, warning=FALSE, message=FALSE, results='hide'}
options(warn=-1)
suppressMessages(library(plyr))

# load stats
stats <- read.csv(file="tmp/stats", head=FALSE, row.names=NULL)
mean_d <- stats[1, 1]
mean_t <- stats[1, 2]
std_d <- stats[2, 1]
std_t <- stats[2, 2]
min_d <- stats[3, 1]
min_t <- stats[3, 2]
max_d <- stats[4, 1]
max_t <- stats[4, 2]

# load MR output
thetas <- data.frame(carrier=character(),
					 feature=character(),
					 t0=double(),
					 t1=double(),
					 stringsAsFactors=FALSE)
input_path <- "output"
filenames <- list.files(input_path, pattern="part-r-*", full.names=TRUE)
for (i in 1:length(filenames))
	thetas <- rbind(thetas, read.csv(file=filenames[i], head=FALSE, row.names=NULL))
names(thetas) <- c("carrier", "feature", "t1", "t0")
carriers <- unique(thetas$carrier)
n_carriers <- length(carriers)

# plot the fitting graph
# loop through top carriers and plot the mean prices for each month
plot_counter <- 0
opar <- par(no.readonly=TRUE)
par(mfrow=c(3, 2))
# get min and max price, then config the y-axis
colcolors <- rainbow(10)

x_d <- seq(min_d, max_d, length.out=5)
x_t <- seq(min_t, max_t, length.out=5)
for (i in 1:n_carriers)
{
	plot_counter <- plot_counter + 1
	ct0 <- thetas[thetas$carrier == carriers[i] & thetas$feature == "D", 3]
	ct1 <- thetas[thetas$carrier == carriers[i] & thetas$feature == "D", 4]
	y_d <- ct1 * ((x_d - mean_d) / std_d) + ct0

	plot(x_d, y_d, type="l",
		 main=carriers[i],
		 xlab="Distance/mile", ylab="Mean Ticket Price",
		 col="blue",
		 xlim=c(0, 6000),
		 ylim=c(0, 1200))
	text(x_d, y_d, round(y_d, 2))
	text(1000, 1100, paste(c("theta_0:", round(ct0, 2)), collapse=" "))
	text(1150, 950, paste(c("theta_1:", round(ct1, 2)), collapse=" "))

	ct0 <- thetas[thetas$carrier == carriers[i] & thetas$feature == "T", 3]
	ct1 <- thetas[thetas$carrier == carriers[i] & thetas$feature == "T", 4]
	y_t <- ct1 * ((x_t - mean_t) / std_t) + ct0
	plot(x_t, y_t, type="l",
		 main=carriers[i],
		 xlab="Air Time/minute", ylab="Mean Ticket Price",
		 col="green",
		 xlim=c(0, 800),
		 ylim=c(0, 1200))
	text(x_t, y_t, round(y_t, 2))
	text(100, 1100, paste(c("theta_0:", round(ct0, 2)), collapse=" "))
	text(110, 950, paste(c("theta_1:", round(ct1, 2)), collapse=" "))
}
par(opar)
```

